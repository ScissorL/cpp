## 内存管理

### 为什么要有虚拟内存？
1. 虚拟内存
   操作系统为每个进程分配独立的一套**虚拟地址**，操作系统会将**虚拟地址映射到真实的物理地址**，各个进程之间的内存互不干扰
2. 内存分段
   - 程序由若干个逻辑分段组成，如可由代码分段、数据分段、栈段、堆段组成。用**分段的形式**将这些段分离出来
   - 分段机制下的虚拟地址由两部分组成，**段选择因子**和**段内偏移量**
   - 存在的问题
     - 内存碎片：多个段之间存在的内存小片段
       可以使用内存交换解决内存碎片问题，但是内存交换的时候需要涉及到硬盘访问，效率很低
3. 内存分页
   **将整个虚拟和物理内存空间切成一段段固定尺寸的大小**，这样的一个内存空间称为**页**
   如果只使用简单的分页，在32位环境下，虚拟地址空间共有4GB，假设一个页的大小是4KB，那么就需要2^20个页，每个页表项需要4个字节大小来存储，那么就需要4MB的内存来存储页表。每个进程都用自己的虚拟空间，即拥有自己的页表，资源消耗就太大了。
   - 多级页表
     将页表分为1024个页表，每个页表中包含1024个页表项，形成二级分页。
     **如果某一个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表**

    <div align="left"><img width="500" src="images/2023-03-27-14-22-59.png"/></div>

   - TLB
     多级页表在虚拟地址到物理地址的转换中多了几道转换的工序，带来了一定时间上的开销。
     - 利用程序的局部性原理，在CPU芯片中，加入一个专门存放程序最常访问的页表项的Cache，这个Cache就是TLB，通常称为页表缓存、转址旁路缓存、快表等。CPU芯片中的MMU负责地址转换和TLB的访问与交互。
     
     <div align="left"><img width="500" src="images/2023-03-27-14-55-24.png"/></div>

4. 段页式内存管理
   内存分段和内存分页可以组合起来使用，称为段页式内存管理。
   - 先将程序划分为多个有逻辑意义的段；
   - 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；
   地址结构由**段号、段内页号和页内偏移**三部分组成。

### malloc是如何分配内存的？
1. malloc是如何分配内存的？
   - 方式一：通过brk()系统调用从堆分配内存；（一般小文件用此方式）
   - 方式二：通过mmap()系统调用在文件映射区域分配内存；
2. malloc分配的是虚拟内存
   如果分配后的虚拟内存没有被访问的话，虚拟内存是不会映射到物理内存的，这样就不会占用物理内存。只有在访问已分配的虚拟地址空间时，操作系统通过查找页表，发现虚拟内存对应的页没有在物理内存中，就会触发缺页中断，然后操作系统会建立虚拟内存和物理内存之间的映射关系。
3. malloc(1)会分配多大的虚拟内存？
   malloc在分配内存时，会先遍历内存池中的空闲内存，如果有合适的就分配，如果没有合适的，就向操作系统申请，而向操作系统申请的时候，并不是老老实实按照用户预期申请的字节数来分配内存空间大小，而是**会预分配更大的空间作为内存池**。
4. free()释放空间，会归还给操作系统吗？
   - malloc 通过 brk() 方式申请的内存，free 释放内存的时候，**并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用**；
   - malloc 通过 mmap() 方式申请的内存， free 释放内存的时候，**会把内存归还给操作系统，内存得到真正的释放**。
5. 为什么不全部使用 mmap 来分配内存？
向操作系统申请内存，是要通过系统调用的，执行系统调用是要进入内核态的，然后在回到用户态，运行态的切换会耗费不少时间。另外因为 mmap 分配的内存每次释放的时候，都会归还给操作系统，于是每次 mmap 分配的虚拟地址都是缺页状态，然后在第一次访问该虚拟地址的时候，就会触发缺页中断。
   - 频繁通过mmap分配内存的话，不仅每次都会发生运行态的切换，还会发生缺页中断（在第一次访问虚拟地址后），这样会导致CPU消耗较大。
   - 为了改进这两个问题，malloc 通过 brk() 系统调用在堆空间申请内存的时候，由于堆空间是连续的，所以直接预分配更大的内存来作为内存池，当内存释放的时候，就缓存在内存池中。
6. 能全部使用 brk 来分配？
   由于 brk() 不会直接把内存归还给操作系统，容易产生越来越多的不可用小片段内存碎片，导致“内存泄漏”
7. free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？
   malloc返回给用户态的内存起始地址比进程的堆空间起始地址多了16字节，这多出来的16字节就是保存了该内存块的描述消息，比如有该内存块的大小。


