## CPP面经
### 1 编译内存相关
#### 1.1 C++ 内存管理
- 栈：存放函数的局部变量，函数参数，返回地址等，由编译器自动分配和释放。
- 堆：动态申请的内存空间，就是由 malloc 分配的内存块。
- 全局区/静态存储区：存放全局变量和静态变量，程序运行结束操作系统自动释放。
- 常量存储区：存放的是常量，不允许修改，程序运行结束自动释放。
- 代码段：存放代码。编译后的二进制文件放在这里。


 

#### 1.2 智能指针及实现原理
- 共享指针(shared_ptr)：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。
- 独占指针(unique_ptr)：独享所有权的智能指针，资源只能被一个指针占用，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造(调用 move()函数)，即一个 unique_ptr 对象赋值给另外一个 unique_ptr 对象，可以通过该方法进行赋值。
- 弱指针 (weak_ptr)：指向shared_ptr 指向的对象，能够解决由 shared_ptr 带来的循环引用问题。

### 4 关键字库函数
#### 4.1 malloc和new
- malloc和free是标准库函数，支持覆盖；new 和 delete是运算符，支持重载。
- malloc仅仅分配内存空间，free 仅仅回收空间，不具备调用构造函数和析构函数功能，用 malloc 分配空间存储类的对象存在风险；new 和 delete除了分配回收功能外，还会调用构造函数和析构函数。

#### 4.2 野指针和悬空指针
- 野指针，指的是没有被初始化过的指针；
- 悬空指针，指针最初指向的内存已经被释放了的一种指针。

#### volatile、mutable和explicit
1. volatile
   该关键字防止优化编译器把变量从内存装入CPU寄存器中，**volatile定义的变量的值是易变，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是寄存器内的备份。多线程中被几个任务共享的变量需要定义为 volatile 类型。**
2. mutable
   



### 5 类相关
#### 5.1 虚函数与纯虚函数
**虚函数**：被 virtual 关键字修饰的成员函数，就是虚函数；
**纯虚函数**：
- 在类中声明时，加上 =0；
- 含有纯虚函数的类称为抽象类，类中只有接口，没有具体的实现方法；
- 继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，则派生类也依然是抽象类，不能实例化对象。

#### 5.2 虚函数和纯虚函数的区别？
- 对于实现纯函数的派生类，该纯虚函数在派生类中被称为虚函数；
- 析构函数最好定义为虚函数，特别是对于含有继承关系的类；
- 析构函数可以定义为纯虚函数，此时，其所在的类为抽象基类，不能创建实例化对象。
#### 5.3 虚函数的实现机制
**实现机制**：虚函数通过虚函数表来实现。虚函数的地址保存在虚函数表中，在类的对象所在的内存空间，保存了指向虚函数表的指针（称为“虚表指针”），通过虚表指针可以找到类对应的虚函数表。虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来指向一个派生类进行操作时，**通过派生类的虚函数表就找到了实际应该调用的函数。**


### 6 语言特性相关
#### 6.1 左值与右值
左值：指表达式结束后依然存在的持久对象。
右值：指表达式结束就不再存在的临时对象。
左值持久，右值短暂
&ensp;
右值引用和左值引用的区别：
- 左值引用不能绑定到要转换的表达式、字面常量或返回右值的表达式。右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。
- 右值引用必须绑定到右值的引用，通过 && 获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。

**std::move** 可以将一个左值强制转化为右值，继而可以通过右值引用使用该值，以用于移动语义。